================================================================================
 REPORTE DE ANÁLISIS COMPARATIVO
 Compresión RLE de Imágenes: Secuencial vs Paralelo
================================================================================

 Fecha:         2026-02-03 16:01:09
 Sistema:       Darwin 25.2.0
 CPU:           Apple M1
 Cores:         8
 RAM:           8.0 GB
 Iteraciones:   5

================================================================================
 1. CONFIGURACIÓN DEL EXPERIMENTO
================================================================================

 Imagen de prueba:
   - Tipo:       Sintética (bandas horizontales)
   - Dimensiones: 4096 x 4096 píxeles
   - Tamaño:     50,331,648 bytes (48 MB)
   - Píxeles:    16,777,216

 Algoritmo:     Run-Length Encoding (RLE) sobre píxeles RGB
 Formato run:   [count: 1B][R: 1B][G: 1B][B: 1B] = 4 bytes por run

 Versión secuencial: 1 hilo de compresión
 Versión paralela:   8 hilos de compresión (1 por core)

================================================================================
 2. RESULTADOS DE EJECUCIÓN
================================================================================

 Tiempos individuales por iteración:

 Iter    Secuencial (s)    Paralelo (s)    Speedup
 ────    ──────────────    ────────────    ───────
   1     0.017960          0.005204         3.45x
   2     0.017195          0.004923         3.49x
   3     0.014969          0.004437         3.37x
   4     0.016640          0.004801         3.46x
   5     0.016125          0.004892         3.29x

 Estadísticas:

                    Secuencial       Paralelo
                    ──────────       ────────
 Promedio:          .016577 s     .004851 s
 Mínimo:            0.014969 s     0.004437 s
 Máximo:            0.017960 s     0.005204 s

================================================================================
 3. ANÁLISIS DE RENDIMIENTO
================================================================================

 Speedup promedio:     3.41x
 Speedup rango:        2.87x — 4.04x
 Eficiencia paralela:  40.0%
 Hilos utilizados:     8
 Speedup teórico max:  8.00x (Ley de Amdahl, parte serial ≈ 0)

 Verificación de corrección:
   Los archivos .rle producidos por ambas versiones son: SÍ idénticos

 Compresión:
   Tamaño original:    50,331,648 bytes
   Tamaño comprimido:  264200 bytes
   Ratio:              99.5%

================================================================================
 4. ANÁLISIS DE USO DE RECURSOS
================================================================================

 Versión Secuencial:
   - Usa 1 core durante toda la ejecución
   - Uso de CPU esperado: ~100% (limitado a 1 core)
   - Memoria: ~50 MB (imagen) + buffer de compresión
   - No tiene overhead de creación de hilos ni sincronización

 Versión Paralela:
   - Usa 8 cores simultáneamente
   - Uso de CPU esperado: hasta 800% (8 cores × 100%)
   - Memoria: ~50 MB (imagen compartida) + 8 buffers de compresión
   - Overhead mínimo: solo variables atómicas para progreso (lock-free)
   - Sin mutex, sin semáforos, sin condiciones de carrera

 La prueba definitiva de paralelismo real es:
   CPU_total > wall_time  →  múltiples cores activos simultáneamente
   En la versión paralela: Speedup CPU ≈ 3.41x confirma uso de ~3.41 cores

================================================================================
 5. CONCLUSIONES
================================================================================

 5.1. Cuándo usar paralelización:

   RECOMENDADO cuando:
   ✓ El problema es "embarrassingly parallel" (divisible sin dependencias)
   ✓ El volumen de datos es grande (>1 MB de procesamiento por hilo)
   ✓ Cada hilo puede trabajar en memoria independiente
   ✓ La proporción serial del algoritmo es pequeña
   ✓ Se necesita reducir latencia en operaciones CPU-bound

   NO RECOMENDADO cuando:
   ✗ El dataset es pequeño (overhead > beneficio)
   ✗ La tarea es I/O-bound (el cuello de botella no es la CPU)
   ✗ Hay muchas dependencias de datos entre secciones
   ✗ La sincronización requerida es compleja (locks, barreras)
   ✗ La portabilidad es más importante que el rendimiento

 5.2. Factores que limitan el speedup:

   - Ley de Amdahl: la porción serial limita el speedup máximo
   - Overhead de creación de hilos (~microsegundos por hilo)
   - Cache effects: cada hilo accede a diferentes regiones de memoria
   - NUMA effects: en sistemas multi-socket, acceso a memoria remota
   - OS scheduling: el kernel puede no distribuir óptimamente
   - False sharing: si las variables atómicas están en la misma cache line

 5.3. Resultado específico de este benchmark:

   Con 8 cores disponibles, se obtuvo un speedup de 3.41x,
   lo que representa una eficiencia del 40.0%.
   La compresión RLE es altamente paralelizable porque cada bloque de filas
   se comprime de forma completamente independiente.

================================================================================
 Fin del reporte
================================================================================
